const { Client, LocalAuth } = require('whatsapp-web.js');
const qrcode = require('qrcode-terminal');
const qrcodeImage = require('qrcode');
const fs = require('fs');
const http = require('http');

// Servidor HTTP simples para health check do Railway
const server = http.createServer((req, res) => {
    console.log(`üì° Requisi√ß√£o recebida: ${req.method} ${req.url}`);
    
    if (req.url === '/qr') {
        console.log('üì± Tentando servir QR Code...');
        // Servir QR Code como imagem
        fs.readFile('./qrcode.png', (err, data) => {
            if (err) {
                console.log('‚ùå QR Code n√£o encontrado:', err.message);
                res.writeHead(404, { 'Content-Type': 'text/plain' });
                res.end('QR Code n√£o encontrado. Aguarde o bot gerar um novo.');
            } else {
                console.log('‚úÖ QR Code enviado com sucesso!');
                res.writeHead(200, { 'Content-Type': 'image/png' });
                res.end(data);
            }
        });
    } else {
        res.writeHead(200, { 'Content-Type': 'text/html' });
        res.end(`
            <html>
                <head><title>Bot WhatsApp</title></head>
                <body style="font-family: Arial, sans-serif; text-align: center; padding: 20px;">
                    <h1>ü§ñ Bot WhatsApp Online!</h1>
                    <p>Status: Aguardando conex√£o</p>
                    <p><a href="/qr" style="background: #25D366; color: white; padding: 10px 20px; text-decoration: none; border-radius: 5px;">üì± Baixar QR Code</a></p>
                    <p>Ou acesse diretamente: <a href="/qr">${req.headers.host}/qr</a></p>
                    <p><small>Se n√£o funcionar, aguarde alguns segundos e tente novamente.</small></p>
                </body>
            </html>
        `);
    }
});

const PORT = process.env.PORT || 3000;
server.listen(PORT, () => {
    console.log(`üöÄ Servidor rodando na porta ${PORT}`);
    console.log(`üåê URL interna: http://localhost:${PORT}`);
    console.log(`üì± QR Code interno: http://localhost:${PORT}/qr`);
    console.log(`üîó Aguarde o Railway gerar a URL p√∫blica...`);
});

// Configura√ß√µes b√°sicas
const CONFIG = {
    welcomeMessage: "üëã Ol√° {user}, seja bem-vindo(a) ao grupo {group}!",
    deleteConfirmation: false,
    maxReconnectAttempts: 5,
    reconnectDelay: 5000
};

// Inicializa o cliente WhatsApp
const client = new Client({
    authStrategy: new LocalAuth({
        dataPath: './auth_folder'
    }),
    puppeteer: {
        headless: true,
        args: [
            '--no-sandbox',
            '--disable-setuid-sandbox',
            '--disable-gpu',
            '--disable-dev-shm-usage',
            '--disable-web-security',
            '--disable-features=VizDisplayCompositor',
            '--disable-extensions',
            '--disable-plugins',
            '--disable-images',
            '--disable-javascript',
            '--no-first-run',
            '--no-default-browser-check',
            '--disable-background-timer-throttling',
            '--disable-backgrounding-occluded-windows',
            '--disable-renderer-backgrounding',
            '--disable-features=TranslateUI',
            '--disable-ipc-flooding-protection'
        ],
        timeout: 60000,
        protocolTimeout: 60000
    }
});

// Armazenamento de estado
let groupSettings = {};
const groupMembersCache = new Map();

// Carrega configura√ß√µes salvas
if (fs.existsSync('group_settings.json')) {
    try {
        groupSettings = JSON.parse(fs.readFileSync('group_settings.json'));
    } catch (e) {
        console.error('Erro ao ler group_settings.json:', e);
        groupSettings = {};
    }
}

// EVENTO: QR Code
client.on('qr', async qr => {
    console.log('üîÑ QR Code gerado!');
    console.log('üì± Escaneie com WhatsApp ‚Üí Aparelhos conectados');
    
    try {
        // Gerar QR Code como imagem PNG
        await qrcodeImage.toFile('./qrcode.png', qr, {
            width: 300,
            margin: 2,
            color: {
                dark: '#000000',
                light: '#FFFFFF'
            }
        });
        
        console.log('‚úÖ QR Code salvo como imagem!');
        console.log('üì± Acesse a URL do Railway + /qr para baixar');
        console.log('üîó Exemplo: https://seu-bot.railway.app/qr');
        
        // Tamb√©m mostrar no terminal (menor)
        qrcode.generate(qr, { small: true });
        
    } catch (error) {
        console.error('‚ùå Erro ao gerar QR Code:', error);
        // Fallback para terminal
        qrcode.generate(qr, { small: true });
    }
});

// --- Mensagem autom√°tica a cada 1h ---
const autoMessageIntervals = {};

function getAutoMessageConfig(groupId) {
    if (!groupSettings[groupId]) groupSettings[groupId] = {};
    if (typeof groupSettings[groupId].autoMessageEnabled === 'undefined') {
        groupSettings[groupId].autoMessageEnabled = false;
    }
    if (typeof groupSettings[groupId].autoMessageText === 'undefined') {
        groupSettings[groupId].autoMessageText = 'Mensagem autom√°tica padr√£o!';
    }
    return groupSettings[groupId];
}

function startAutoMessage(groupId, chat) {
    stopAutoMessage(groupId);
    const config = getAutoMessageConfig(groupId);
    if (!config.autoMessageEnabled) return;
    autoMessageIntervals[groupId] = setInterval(async () => {
        try {
            await chat.sendMessage(config.autoMessageText);
        } catch (e) {
            console.error('Erro ao enviar mensagem autom√°tica:', e);
        }
    }, 60 * 60 * 1000); // 1 hora
}

function stopAutoMessage(groupId) {
    if (autoMessageIntervals[groupId]) {
        clearInterval(autoMessageIntervals[groupId]);
        delete autoMessageIntervals[groupId];
    }
}

async function toggleAutoMessage(chat, msg) {
    const groupId = chat.id._serialized;
    const config = getAutoMessageConfig(groupId);
    config.autoMessageEnabled = !config.autoMessageEnabled;
    saveGroupSettings();
    if (config.autoMessageEnabled) {
        startAutoMessage(groupId, chat);
        await msg.reply('‚úÖ Mensagem autom√°tica ativada!');
    } else {
        stopAutoMessage(groupId);
        await msg.reply('‚ùå Mensagem autom√°tica desativada!');
    }
}

async function setAutoMessageText(chat, msg) {
    const groupId = chat.id._serialized;
    const config = getAutoMessageConfig(groupId);
    const texto = msg.body.replace('!setanuncio', '').trim();
    if (!texto) {
        await msg.reply('‚ö†Ô∏è Use: !setanuncio Sua mensagem aqui');
        return;
    }
    config.autoMessageText = texto;
    saveGroupSettings();
    await msg.reply('‚úÖ Mensagem autom√°tica configurada!');
}

// EVENTO: Bot pronto
client.on('ready', async () => {
    console.log('‚úÖ Bot conectado e pronto!');
    try {
        // Carrega cache inicial de membros dos grupos
        const chats = await client.getChats();
        const groups = chats.filter(chat => chat.isGroup);
        for (const group of groups) {
            try {
                const metadata = await client.getChatById(group.id._serialized);
                groupMembersCache.set(
                    group.id._serialized, 
                    new Set(metadata.participants.map(p => p.id._serialized))
                );
                console.log(`[CACHE] Membros carregados para o grupo ${group.name}`);
            } catch (error) {
                console.error(`Erro ao carregar metadata do grupo ${group.name}:`, error);
            }
        }
        // Iniciar auto-mensagens para grupos ativados
        for (const groupId in groupSettings) {
            if (groupSettings[groupId].autoMessageEnabled) {
                try {
                    const chat = await client.getChatById(groupId);
                    startAutoMessage(groupId, chat);
                } catch (e) {
                    console.error('Erro ao iniciar auto-mensagem:', e);
                }
            }
        }
    } catch (error) {
        console.error('Erro ao inicializar cache de membros:', error);
    }
});

// Fun√ß√£o para obter informa√ß√µes do chat
async function getChatInfo(msg) {
    try {
        const chat = await msg.getChat();
        const isGroup = chat.isGroup;
        let participants = [];
        if (isGroup) {
            const metadata = await client.getChatById(chat.id._serialized);
            participants = metadata.participants;
        }
        return {
            chat,
            isGroup,
            participants
        };
    } catch (error) {
        console.error('Erro ao obter info do chat:', error);
        return null;
    }
}

// Fun√ß√£o para verificar se o usu√°rio √© admin
async function isUserAdmin(msg, participants) {
    try {
        if (!participants || !Array.isArray(participants)) return false;
        const userId = (msg.author || msg.from);
        const admin = participants.find(p => p.id._serialized === userId && (p.isAdmin || p.isSuperAdmin));
        return !!admin;
    } catch (error) {
        console.error('Erro ao verificar admin:', error);
        return false;
    }
}

// Fun√ß√£o melhorada para detectar mensagens de novo membro
function isNewMemberMessage(msg) {
    if (msg.type !== 'gp2') return false;
    const joinPatterns = [
        /entrou no grupo/,
        /foi adicionado/,
        /adicionou \+\d+@c\.us/,
        /participant added/,
        /membro adicionado/,
        /added by invitation/,
        /voc√™ adicionou/,
        /added \+\d+/,
        /joined using/
    ];
    return joinPatterns.some(pattern => pattern.test(msg.body.toLowerCase()));
}

// Fun√ß√£o de boas-vindas corrigida
async function handleNewMember(msg) {
    try {
        console.log('[DEBUG] Verificando nova mensagem de grupo:', msg.body);
        const chat = await msg.getChat();
        if (!chat.isGroup) return;
        const metadata = await client.getChatById(chat.id._serialized);
        const isAdmin = metadata.participants.find(p => p.id._serialized === client.info.wid._serialized && (p.isAdmin || p.isSuperAdmin));
        if (!isAdmin) {
            console.log('[BOAS-VINDAS] Bot n√£o √© admin. Ignorando.');
            return;
        }
        const currentParticipants = new Set(metadata.participants.map(p => p.id._serialized));
        const cachedMembers = groupMembersCache.get(chat.id._serialized) || new Set();
        const newMembers = [...currentParticipants].filter(id => !cachedMembers.has(id));
        if (newMembers.length === 0) {
            console.log('[BOAS-VINDAS] Nenhum novo membro detectado.');
            return;
        }
        const groupId = chat.id._serialized;
        const groupConfig = groupSettings[groupId] || {};
        if (groupConfig.welcomeEnabled === false) {
            console.log('[BOAS-VINDAS] Boas-vindas desativadas para este grupo.');
            return;
        }
        console.log(`[BOAS-VINDAS] Novos membros detectados: ${newMembers.length}`);
        for (const memberId of newMembers) {
            try {
                const contact = await client.getContactById(memberId);
                const welcomeText = CONFIG.welcomeMessage
                    .replace('{user}', `@${contact.id.user}`)
                    .replace('{group}', chat.name);
                await chat.sendMessage(welcomeText, {
                    mentions: [contact]
                });
                console.log(`[BOAS-VINDAS] Mensagem enviada para @${contact.id.user}`);
                cachedMembers.add(contact.id._serialized);
                groupMembersCache.set(groupId, cachedMembers);
            } catch (memberError) {
                console.error(`Erro com membro ${memberId}:`, memberError);
            }
        }
        // Chama anti-fake ap√≥s boas-vindas
        if (chat.isGroup) {
            await handleAntiFake(chat);
        }
    } catch (error) {
        console.error('Erro no handleNewMember:', error);
    }
}

// Fun√ß√£o para ativar/desativar o bot no grupo
async function toggleBotActivation(chat, msg, activate) {
    try {
        const chatInfo = await getChatInfo(msg);
        if (!chatInfo) return;
        const senderIsAdmin = await isUserAdmin(msg, chatInfo.participants);
        if (!senderIsAdmin) {
            return msg.reply('‚ùå Voc√™ precisa ser admin para executar este comando!');
        }
        groupSettings[chat.id._serialized] = {
            ...groupSettings[chat.id._serialized],
            botActive: activate
        };
        saveGroupSettings();
        await msg.reply(`‚úÖ Bot ${activate ? 'ativado' : 'desativado'} neste grupo!`);
        if (activate) {
            await chat.sendMessage(`ü§ñ Bot ativado! Digite *!ajuda* para ver os comandos dispon√≠veis.`);
        }
    } catch (error) {
        console.error('Erro ao alternar ativa√ß√£o do bot:', error);
        msg.reply('‚ùå Ocorreu um erro ao executar este comando.');
    }
}

// Adiciona op√ß√µes ao groupSettings
function getGroupConfig(groupId) {
    if (!groupSettings[groupId]) {
        groupSettings[groupId] = {};
    }
    if (typeof groupSettings[groupId].antiFake === 'undefined') {
        groupSettings[groupId].antiFake = false;
    }
    if (typeof groupSettings[groupId].antiLink === 'undefined') {
        groupSettings[groupId].antiLink = false;
    }
    return groupSettings[groupId];
}

// Fun√ß√£o para ativar/desativar anti-fake
async function toggleAntiFake(chat, msg) {
    const groupId = chat.id._serialized;
    const config = getGroupConfig(groupId);
    config.antiFake = !config.antiFake;
    saveGroupSettings();
    await msg.reply(`‚úÖ Anti-fake ${config.antiFake ? 'ativado' : 'desativado'} neste grupo!`);
}

// Fun√ß√£o para ativar/desativar anti-link
async function toggleAntiLink(chat, msg) {
    const groupId = chat.id._serialized;
    const config = getGroupConfig(groupId);
    config.antiLink = !config.antiLink;
    saveGroupSettings();
    await msg.reply(`‚úÖ Anti-link ${config.antiLink ? 'ativado' : 'desativado'} neste grupo!`);
}

// Fun√ß√£o para verificar e agir sobre links
async function handleAntiLink(msg, chat, participants) {
    const groupId = chat.id._serialized;
    const config = getGroupConfig(groupId);
    if (!config.antiLink) return;
    const isAdmin = await isUserAdmin(msg, participants);
    const linkRegex = /https?:\/\//i;
    if (linkRegex.test(msg.body) && !isAdmin) {
        try {
            await msg.delete(true);
            await chat.sendMessage(`üö´ Mensagem com link apagada!`, { mentions: [msg.author || msg.from] });
        } catch (e) {
            console.error('Erro ao apagar mensagem com link:', e);
        }
    }
}

// Fun√ß√£o para anti-fake ao entrar novo membro
async function handleAntiFake(chat) {
    const groupId = chat.id._serialized;
    const config = getGroupConfig(groupId);
    if (!config.antiFake) return;
    const metadata = await client.getChatById(groupId);
    for (const participant of metadata.participants) {
        if (!participant.id.user.startsWith('55')) {
            try {
                await chat.removeParticipants([participant.id._serialized]);
                await chat.sendMessage(`üö´ Usu√°rio removido por n√£o ser do Brasil (+55): @${participant.id.user}`, { mentions: [participant.id._serialized] });
            } catch (e) {
                console.error('Erro ao remover estrangeiro:', e);
            }
        }
    }
}

// Fun√ß√£o para lidar com comandos
async function handleCommand(msg) {
    let timeout;
    try {
        timeout = setTimeout(async () => {
            await msg.reply('‚åõ O comando demorou muito para responder');
        }, 15000);
        
        const command = msg.body.toLowerCase().trim().split(' ')[0];
        const chatInfo = await getChatInfo(msg);
        if (!chatInfo) return;
        
        const { chat, isGroup, participants } = chatInfo;
        
        // Verificar se √© admin para TODOS os comandos
        const senderIsAdmin = await isUserAdmin(msg, participants);
        if (!senderIsAdmin) {
            return msg.reply('‚ùå Voc√™ precisa ser admin para executar este comando!');
        }
        
        // Verificar se o bot est√° ativo (exceto para comandos de ativa√ß√£o)
        const allowedWhenDisabled = ['!ativar', '!ajuda', '!status'];
        if (isGroup && !allowedWhenDisabled.includes(command)) {
            const isBotActive = groupSettings[chat.id._serialized]?.botActive !== false;
            if (!isBotActive) return;
        }
        
        switch (command) {
            case '!ativar':
                if (!isGroup) return;
                await toggleBotActivation(chat, msg, true);
                break;
            case '!desativar':
                if (!isGroup) return;
                await toggleBotActivation(chat, msg, false);
                break;
            case '!fechar':
                if (!isGroup) return;
                await setGroupLock(chat, msg, true);
                break;
            case '!abrir':
                if (!isGroup) return;
                await setGroupLock(chat, msg, false);
                break;
            case '!apagar':
                await deleteMessage(msg);
                break;
            case '!boasvindas':
                if (!isGroup) return;
                await toggleWelcome(chat, msg);
                break;
            case '!banir':
                if (!isGroup) return;
                await banUser(chat, msg);
                break;
            case '!cite':
                if (!isGroup) return;
                await mentionAll(chat, msg, participants);
                break;
            case '!ajuda':
                await showHelp(msg);
                break;
            case '!status':
                if (!isGroup) return;
                await checkBotStatus(chat, msg);
                break;
            case '!antifake':
                if (!isGroup) return;
                await toggleAntiFake(chat, msg);
                break;
            case '!antilink':
                if (!isGroup) return;
                await toggleAntiLink(chat, msg);
                break;
            case '!autoanuncio':
                if (!isGroup) return;
                await toggleAutoMessage(chat, msg);
                break;
            case '!setanuncio':
                if (!isGroup) return;
                await setAutoMessageText(chat, msg);
                break;
            default:
                return; // Ignora comandos desconhecidos
        }
    } catch (error) {
        console.error('Erro ao executar comando:', error);
        msg.reply('‚ùå Ocorreu um erro ao executar este comando.');
    } finally {
        clearTimeout(timeout);
    }
}

// EVENTO: Mensagens recebidas
client.on('message', async msg => {
    try {
        console.log(`üì® Mensagem recebida: "${msg.body}" de ${msg.author || msg.from}`);
        
        if (msg.fromMe) {
            console.log('‚ùå Mensagem minha, ignorando');
            return;
        }
        
        if (isNewMemberMessage(msg)) {
            console.log('[EVENTO] Mensagem de novo membro detectada:', msg.body);
            await handleNewMember(msg);
        }
        
        if (msg.body.startsWith('!')) {
            console.log('üîß Comando detectado:', msg.body);
            await handleCommand(msg);
        }
        
        // Anti-link
        const chatInfo = await getChatInfo(msg);
        if (chatInfo && chatInfo.isGroup) {
            await handleAntiLink(msg, chatInfo.chat, chatInfo.participants);
        }
    } catch (error) {
        console.error('‚ùå Erro ao processar mensagem:', error);
    }
});

// Fun√ß√£o para verificar status do bot no grupo
async function checkBotStatus(chat, msg) {
    try {
        const isActive = groupSettings[chat.id._serialized]?.botActive !== false;
        const welcomeEnabled = groupSettings[chat.id._serialized]?.welcomeEnabled !== false;
        await msg.reply(
            `‚ÑπÔ∏è *Status do bot*:\n` +
            `- *Ativo*: ${isActive ? '‚úÖ SIM' : '‚ùå N√ÉO'}\n` +
            `- *Boas-vindas*: ${welcomeEnabled ? '‚úÖ LIGADO' : '‚ùå DESLIGADO'}\n` +
            `- *Membros no cache*: ${groupMembersCache.get(chat.id._serialized)?.size || 0}`
        );
    } catch (error) {
        console.error('Erro ao verificar status:', error);
        msg.reply('‚ùå Ocorreu um erro ao verificar o status.');
    }
}

// Fun√ß√£o para mencionar todos os participantes
async function mentionAll(chat, msg, participants) {
    try {
        if (!msg.hasQuotedMsg) {
            return msg.reply('‚ö†Ô∏è Responda a mensagem com *!cite* para marcar todos ocultamente');
        }
        const quotedMsg = await msg.getQuotedMessage();
        const mentions = participants
            .filter(p => !p.isAdmin && !p.isSuperAdmin)
            .map(p => p.id._serialized);
        if (mentions.length === 0) {
            return msg.reply('‚ùå N√£o h√° participantes para mencionar!');
        }
        await chat.sendMessage(quotedMsg.body, {
            mentions: mentions
        });
        await msg.delete();
        await quotedMsg.delete();
        await chat.sendMessage(`‚úÖ ${mentions.length} membros foram notificados discretamente`, {
            sendSeen: true
        });
    } catch (error) {
        console.error('Erro ao mencionar todos:', error);
        msg.reply('‚ùå Ocorreu um erro ao mencionar os membros.');
    }
}

// Fun√ß√£o para banir usu√°rios
async function banUser(chat, msg) {
    try {
        if (!msg.hasQuotedMsg && msg.mentionedIds.length === 0) {
            return msg.reply('‚ö†Ô∏è Marque o usu√°rio ou responda sua mensagem com *!banir*');
        }
        let userToBan;
        if (msg.hasQuotedMsg) {
            const quotedMsg = await msg.getQuotedMessage();
            userToBan = quotedMsg.author || quotedMsg.from;
        } else {
            userToBan = msg.mentionedIds[0];
        }
        if (userToBan === (msg.author || msg.from)) {
            return msg.reply('‚ùå Voc√™ n√£o pode banir a si mesmo!');
        }
        const me = await client.getContactById(client.info.wid._serialized);
        if (userToBan === me.id._serialized) {
            return msg.reply('‚ùå Voc√™ n√£o pode banir o bot!');
        }
        await chat.removeParticipants([userToBan]);
        await msg.reply('‚úÖ Usu√°rio banido com sucesso!');
    } catch (error) {
        console.error('Erro ao banir usu√°rio:', error);
        msg.reply('‚ùå Ocorreu um erro ao banir o usu√°rio. Verifique se sou admin.');
    }
}

// Fun√ß√£o para apagar mensagens
async function deleteMessage(msg) {
    try {
        if (!msg.hasQuotedMsg) {
            return msg.reply('‚ö†Ô∏è Responda a mensagem com *!apagar*');
        }
        const quotedMsg = await msg.getQuotedMessage();
        await quotedMsg.delete(true);
        if (CONFIG.deleteConfirmation) {
            await msg.reply('üóëÔ∏è Mensagem apagada com sucesso!');
        } else {
            await msg.delete();
        }
    } catch (error) {
        console.error('Erro ao apagar mensagem:', error);
        msg.reply('‚ùå N√£o foi poss√≠vel apagar a mensagem. Verifique minhas permiss√µes.');
    }
}

// Fun√ß√£o de ajuda
async function showHelp(msg) {
    try {
        const helpText = `
üåü *MENU DE AJUDA* üåü

üîß *Controle do Bot*:
‚îú‚îÄ‚îÄ !ativar - Ativa o bot no grupo
‚îú‚îÄ‚îÄ !desativar - Desativa o bot no grupo
‚îî‚îÄ‚îÄ !status - Mostra status do bot

üìå *Administra√ß√£o* (apenas admins):
‚îú‚îÄ‚îÄ !abrir - Libera o grupo para todos
‚îú‚îÄ‚îÄ !fechar - Restringe para apenas admins
‚îú‚îÄ‚îÄ !banir - Remove usu√°rio do grupo
‚îú‚îÄ‚îÄ !cite - Marca todos ocultamente
‚îú‚îÄ‚îÄ !apagar - Apaga mensagem
‚îú‚îÄ‚îÄ !antifake - Ativa/desativa anti-fake
‚îú‚îÄ‚îÄ !antilink - Ativa/desativa anti-link
‚îú‚îÄ‚îÄ !autoanuncio - Ativa/desativa mensagem autom√°tica a cada 1h
‚îú‚îÄ‚îÄ !setanuncio <msg> - Define a mensagem autom√°tica

üéâ *Configura√ß√µes*:
‚îî‚îÄ‚îÄ !boasvindas - Ativa/desativa mensagens de boas-vindas

‚ÑπÔ∏è Todos os comandos devem come√ßar com "!"
        `;
        await msg.reply(helpText);
    } catch (error) {
        console.error('Erro ao mostrar ajuda:', error);
    }
}

// Fun√ß√µes auxiliares
async function setGroupLock(chat, msg, lock) {
    try {
        await chat.setMessagesAdminsOnly(lock);
        groupSettings[chat.id._serialized] = {
            ...groupSettings[chat.id._serialized],
            isLocked: lock
        };
        saveGroupSettings();
        await msg.reply(`‚úÖ Grupo ${lock ? 'fechado' : 'aberto'} com sucesso!`);
    } catch (error) {
        console.error(`Erro ao ${lock ? 'fechar' : 'abrir'} grupo:`, error);
        msg.reply(`‚ùå N√£o foi poss√≠vel ${lock ? 'fechar' : 'abrir'} o grupo. Verifique minhas permiss√µes.`);
    }
}

async function toggleWelcome(chat, msg) {
    try {
        const current = groupSettings[chat.id._serialized]?.welcomeEnabled !== false;
        groupSettings[chat.id._serialized] = {
            ...groupSettings[chat.id._serialized],
            welcomeEnabled: !current
        };
        saveGroupSettings();
        if (!current) {
            const metadata = await client.getChatById(chat.id._serialized);
            groupMembersCache.set(
                chat.id._serialized, 
                new Set(metadata.participants.map(p => p.id._serialized))
            );
            console.log(`[CACHE] Cache de membros atualizado para ${chat.name}`);
        }
        await msg.reply(`‚úÖ Boas-vindas ${current ? 'desativadas' : 'ativadas'}!`);
    } catch (error) {
        console.error('Erro ao alternar boas-vindas:', error);
        msg.reply('‚ùå Ocorreu um erro ao alterar as configura√ß√µes de boas-vindas.');
    }
}

function saveGroupSettings() {
    try {
        fs.writeFileSync('group_settings.json', JSON.stringify(groupSettings, null, 2));
    } catch (error) {
        console.error('Erro ao salvar configura√ß√µes:', error);
    }
}

// Sistema de reconex√£o autom√°tica
let reconnectAttempts = 0;

client.on('disconnected', async (reason) => {
    console.log(`‚ùå Conex√£o perdida (${reason}), tentando reconectar...`);
    if (reconnectAttempts < CONFIG.maxReconnectAttempts) {
        reconnectAttempts++;
        await new Promise(resolve => setTimeout(resolve, CONFIG.reconnectDelay));
        try {
            await client.initialize();
            reconnectAttempts = 0;
            console.log('‚úÖ Reconex√£o bem-sucedida!');
        } catch (err) {
            console.error(`Tentativa ${reconnectAttempts} falhou:`, err);
        }
    } else {
        console.error('‚ùå M√°ximo de tentativas de reconex√£o atingido');
        process.exit(1);
    }
});

// Inicializa o bot
client.initialize().catch(error => {
    console.error('Erro ao inicializar o bot:', error);
    process.exit(1);
});

// Tratamento de erros globais
process.on('unhandledRejection', error => {
    console.error('Erro n√£o tratado:', error);
});

process.on('uncaughtException', error => {
    console.error('Exce√ß√£o n√£o capturada:', error);
});

// Adicionar evento nativo para detectar novos participantes
client.on('group_join', async (notification) => {
    try {
        const chat = await notification.getChat();
        const groupId = chat.id._serialized;
        const groupConfig = groupSettings[groupId] || {};
        if (groupConfig.welcomeEnabled === false) {
            console.log('[BOAS-VINDAS] Boas-vindas desativadas para este grupo.');
            return;
        }
        // notification.recipientIds pode conter 1 ou mais membros
        const recipientIds = notification.recipientIds || [];
        for (const memberId of recipientIds) {
            try {
                const contact = await client.getContactById(memberId);
                const welcomeText = CONFIG.welcomeMessage
                    .replace('{user}', `@${contact.id.user}`)
                    .replace('{group}', chat.name);
                await chat.sendMessage(welcomeText, {
                    mentions: [contact]
                });
                console.log(`[BOAS-VINDAS] Mensagem enviada para @${contact.id.user} via evento nativo`);
            } catch (memberError) {
                console.error(`[BOAS-VINDAS] Erro ao enviar mensagem para membro ${memberId}:`, memberError);
            }
        }
    } catch (error) {
        console.error('[BOAS-VINDAS] Erro ao enviar mensagem de boas-vindas via evento nativo:', error);
    }
});